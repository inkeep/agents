---
title: JSON Schema guide for components
sidebarTitle: JSON Schemas
description: Guide for writing valid JSON Schemas for data components and artifact components
icon: LuFileCheck
keywords: JSON Schema, data components, artifact components, LLM compatibility
---

This guide shows you how to write valid JSON Schemas for your components. The framework validates these schemas to ensure they work properly with LLMs.

## Why validation matters

LLMs need clear, structured information to understand how to use your components. The validation ensures:

- All properties have descriptions (so the LLM knows what they're for)
- Required fields are clearly marked
- The schema structure is correct

## Data component props

When creating data components, your `props` field must be a valid JSON Schema:

### ✅ Valid example

```json
{
  "type": "object",
  "properties": {
    "title": {
      "type": "string",
      "description": "The title of the content item"
    },
    "url": {
      "type": "string",
      "description": "The URL where this content can be accessed"
    },
    "tags": {
      "type": "array",
      "description": "List of tags to categorize this content",
      "items": {
        "type": "string"
      }
    },
    "priority": {
      "type": "string",
      "enum": ["low", "medium", "high"],
      "description": "Priority level for this content item"
    }
  },
  "required": ["title", "url"]
}
```

### ❌ Common mistakes

```json
{
  // ❌ Missing "type": "object"
  "properties": {
    "title": {
      "type": "string"
      // ❌ Missing description
    }
  }
  // ❌ Missing required array
}
```

## Artifact component schemas

Artifact components use a single unified schema called `props` with `inPreview` indicators.

### Unified props schema

Fields marked with `inPreview: true` appear in summary views, while all fields are stored in the database:

```json
{
  "type": "object",
  "properties": {
    "title": {
      "type": "string",
      "description": "Title of the artifact",
      "inPreview": true
    },
    "status": {
      "type": "string",
      "enum": ["draft", "published", "archived"],
      "description": "Current status of the artifact",
      "inPreview": true
    },
    "createdAt": {
      "type": "string",
      "format": "date-time",
      "description": "When the artifact was created",
      "inPreview": true
    },
    "content": {
      "type": "string",
      "description": "Main content of the artifact"
    },
    "metadata": {
      "type": "object",
      "description": "Additional metadata for the artifact",
      "properties": {
        "author": {
          "type": "string",
          "description": "Who created this artifact"
        },
        "version": {
          "type": "string",
          "description": "Version number of the artifact"
        }
      },
      "required": ["author"]
    },
    "attachments": {
      "type": "array",
      "description": "Files attached to this artifact",
      "items": {
        "type": "object",
        "properties": {
          "filename": {
            "type": "string",
            "description": "Name of the attached file"
          },
          "url": {
            "type": "string",
            "description": "URL to download the file"
          }
        },
        "required": ["filename", "url"]
      }
    }
  },
  "required": ["title", "status", "content"]
}
```

### Using Zod schemas with preview helpers

You can also use Zod schemas with the preview helper:

```typescript
import { z } from 'zod';
import { preview } from '@inkeep/agents-core/utils/schema-conversion';

const artifactSchema = z.object({
  title: preview(z.string().describe("Title of the artifact")),
  status: preview(z.enum(["draft", "published", "archived"]).describe("Current status")),
  content: z.string().describe("Main content of the artifact"),
  metadata: z.object({
    author: z.string().describe("Who created this artifact"),
    version: z.string().describe("Version number")
  })
});
```

## Validation rules

The editor enforces these rules:

1. **Must be an object**: Top level must have `"type": "object"`
2. **Must have properties**: Include a `"properties"` object
3. **Must have required array**: Include a `"required"` array (even if empty)
4. **All properties need descriptions**: Every property must have a `"description"` field

### Quick template

Need a starting point? Click the "Template" button in the editor, or use this:

```json
{
  "type": "object",
  "properties": {
    "example_property": {
      "type": "string",
      "description": "Description of what this property represents"
    }
  },
  "required": ["example_property"]
}
```

## Common patterns

### Optional vs required

```json
{
  "type": "object",
  "properties": {
    "name": {
      "type": "string",
      "description": "User's full name"
    },
    "email": {
      "type": "string",
      "description": "User's email address (optional)"
    }
  },
  "required": ["name"]
  // email is optional since it's not in the required array
}
```

### Enums for fixed choices

```json
{
  "type": "object",
  "properties": {
    "category": {
      "type": "string",
      "enum": ["work", "personal", "urgent"],
      "description": "Category to organize this item"
    }
  },
  "required": ["category"]
}
```

### Arrays with specific item types

```json
{
  "type": "object",
  "properties": {
    "images": {
      "type": "array",
      "description": "List of image URLs for this item",
      "items": {
        "type": "string",
        "format": "uri"
      }
    }
  },
  "required": ["images"]
}
```

That's it! The editor will guide you with real-time validation feedback as you type.
