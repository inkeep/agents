/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { RequestHandlerExtra } from '@modelcontextprotocol/sdk/shared/protocol.js';
import type {
  GetPromptResult,
  ServerNotification,
  ServerRequest,
} from '@modelcontextprotocol/sdk/types.js';
import type { objectOutputType, ZodOptional, ZodType, ZodTypeAny, ZodTypeDef } from 'zod';
import type { InkeepAgentsCore } from '../core.js';
import type { ConsoleLogger } from './console-logger.js';
import type { MCPScope } from './scopes.js';

// '@modelcontextprotocol/sdk' currently does not export this type
export type PromptArgsRawShape = {
  [k: string]:
    | ZodType<string, ZodTypeDef, string>
    | ZodOptional<ZodType<string, ZodTypeDef, string>>;
};

export type PromptDefinition<Args extends undefined | PromptArgsRawShape = undefined> =
  Args extends PromptArgsRawShape
    ? {
        name: string;
        description?: string;
        scopes?: MCPScope[];
        args: Args;
        prompt: (
          client: InkeepAgentsCore,
          args: objectOutputType<Args, ZodTypeAny>,
          extra: RequestHandlerExtra<ServerRequest, ServerNotification>
        ) => GetPromptResult | Promise<GetPromptResult>;
      }
    : {
        name: string;
        description?: string;
        scopes?: MCPScope[];
        args?: undefined;
        prompt: (
          client: InkeepAgentsCore,
          extra: RequestHandlerExtra<ServerRequest, ServerNotification>
        ) => GetPromptResult | Promise<GetPromptResult>;
      };

// Optional function to assist with formatting prompt results
export async function formatResult(value: string): Promise<GetPromptResult> {
  return {
    messages: [
      {
        role: 'user',
        content: {
          type: 'text',
          text: value,
        },
      },
    ],
  };
}

export function createRegisterPrompt(
  logger: ConsoleLogger,
  server: McpServer,
  getSDK: () => InkeepAgentsCore,
  allowedScopes: Set<MCPScope>
): <A extends PromptArgsRawShape | undefined>(prompt: PromptDefinition<A>) => void {
  return <A extends PromptArgsRawShape | undefined>(prompt: PromptDefinition<A>): void => {
    const scopes = prompt.scopes ?? [];
    if (allowedScopes.size > 0 && scopes.length === 0) {
      return;
    }

    if (allowedScopes.size > 0 && !scopes.every((s: MCPScope) => allowedScopes.has(s))) {
      return;
    }

    if (prompt.args) {
      if (prompt.description) {
        server.prompt(
          prompt.name,
          prompt.description,
          prompt.args as any,
          async (args: any, ctx: any) => prompt.prompt(getSDK(), args, ctx)
        );
      } else {
        server.prompt(prompt.name, prompt.args as any, async (args: any, ctx: any) =>
          prompt.prompt(getSDK(), args, ctx)
        );
      }
    } else {
      if (prompt.description) {
        server.prompt(prompt.name, prompt.description, async (ctx) => prompt.prompt(getSDK(), ctx));
      } else {
        server.prompt(prompt.name, async (ctx) => prompt.prompt(getSDK(), ctx));
      }
    }

    logger.debug('Registered prompt', { name: prompt.name });
  };
}
