/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: f4b1b69ae29a
 */

import { InkeepAgentsCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { APIError } from "../models/errors/apierror.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import {
  SetMcpToolGithubAccessRequest,
  SetMcpToolGithubAccessRequest$zodSchema,
  SetMcpToolGithubAccessResponse,
  SetMcpToolGithubAccessResponse$zodSchema,
} from "../models/setmcptoolgithubaccessop.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

export enum SetMcpToolGithubAccessAcceptEnum {
  applicationJsonAccept = "application/json",
  applicationProblemPlusJsonAccept = "application/problem+json",
}

/**
 * Set MCP tool GitHub repository access
 *
 * @remarks
 * Configures which GitHub repositories an MCP tool can access. When mode is "all", the tool has access to all repositories the project can access. When mode is "selected", the tool is scoped to specific repositories (repositoryIds required). This replaces any existing access configuration. This endpoint only works for GitHub workapp MCP tools (isWorkApp=true and URL contains /github).
 */
export function toolsSetMcpToolGithubAccess(
  client$: InkeepAgentsCore,
  request: SetMcpToolGithubAccessRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    SetMcpToolGithubAccessResponse,
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >
> {
  return new APIPromise($do(
    client$,
    request,
    options,
  ));
}

async function $do(
  client$: InkeepAgentsCore,
  request: SetMcpToolGithubAccessRequest,
  options?: RequestOptions & {
    acceptHeaderOverride?: SetMcpToolGithubAccessAcceptEnum;
  },
): Promise<
  [
    Result<
      SetMcpToolGithubAccessResponse,
      | APIError
      | SDKValidationError
      | UnexpectedClientError
      | InvalidRequestError
      | RequestAbortedError
      | RequestTimeoutError
      | ConnectionError
    >,
    APICall,
  ]
> {
  const parsed$ = safeParse(
    request,
    (value$) => SetMcpToolGithubAccessRequest$zodSchema.parse(value$),
    "Input validation failed",
  );
  if (!parsed$.ok) {
    return [parsed$, { status: "invalid" }];
  }
  const payload$ = parsed$.value;
  const body$ = encodeJSON("body", payload$.body, { explode: true });

  const pathParams$ = {
    projectId: encodeSimple("projectId", payload$.projectId, {
      explode: false,
      charEncoding: "percent",
    }),
    tenantId: encodeSimple("tenantId", payload$.tenantId, {
      explode: false,
      charEncoding: "percent",
    }),
    toolId: encodeSimple("toolId", payload$.toolId, {
      explode: false,
      charEncoding: "percent",
    }),
  };
  const path$ = pathToFunc(
    "/manage/tenants/{tenantId}/projects/{projectId}/tools/{toolId}/github-access",
  )(
    pathParams$,
  );

  const headers$ = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: options?.acceptHeaderOverride
      || "application/json;q=1, application/problem+json;q=0",
  }));
  const securityInput = await extractSecurity(client$._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client$._options,
    baseURL: options?.serverURL ?? client$._baseURL ?? "",
    operationID: "set-mcp-tool-github-access",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client$._options.security,
    retryConfig: options?.retries
      || client$._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || [
      "429",
      "500",
      "502",
      "503",
      "504",
    ],
  };

  const requestRes = client$._createRequest(context, {
    security: requestSecurity,
    method: "PUT",
    baseURL: options?.serverURL,
    path: path$,
    headers: headers$,
    body: body$,
    userAgent: client$._options.userAgent,
    timeoutMs: options?.timeoutMs || client$._options.timeoutMs
      || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req$ = requestRes.value;

  const doResult = await client$._do(req$, {
    context,
    errorCodes: [],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req$ }];
  }
  const response = doResult.value;
  const responseFields$ = {
    HttpMeta: { Response: response, Request: req$ },
  };

  const [result$] = await M.match<
    SetMcpToolGithubAccessResponse,
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >(
    M.json(200, SetMcpToolGithubAccessResponse$zodSchema, { key: "object" }),
    M.json(400, SetMcpToolGithubAccessResponse$zodSchema, {
      ctype: "application/problem+json",
      key: "BadRequest",
    }),
    M.json(401, SetMcpToolGithubAccessResponse$zodSchema, {
      ctype: "application/problem+json",
      key: "Unauthorized",
    }),
    M.json(403, SetMcpToolGithubAccessResponse$zodSchema, {
      ctype: "application/problem+json",
      key: "Forbidden",
    }),
    M.json(404, SetMcpToolGithubAccessResponse$zodSchema, {
      ctype: "application/problem+json",
      key: "NotFound",
    }),
    M.json(422, SetMcpToolGithubAccessResponse$zodSchema, {
      ctype: "application/problem+json",
      key: "UnprocessableEntity",
    }),
    M.json(500, SetMcpToolGithubAccessResponse$zodSchema, {
      ctype: "application/problem+json",
      key: "InternalServerError",
    }),
  )(response, req$, { extraFields: responseFields$ });

  return [result$, { status: "complete", request: req$, response }];
}
