/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: 5e7d447d116a
 */

import { InkeepAgentsCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { APIError } from "../models/errors/apierror.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import {
  GetMcpToolGithubAccessRequest,
  GetMcpToolGithubAccessRequest$zodSchema,
  GetMcpToolGithubAccessResponse,
  GetMcpToolGithubAccessResponse$zodSchema,
} from "../models/getmcptoolgithubaccessop.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

export enum GetMcpToolGithubAccessAcceptEnum {
  applicationJsonAccept = "application/json",
  applicationProblemPlusJsonAccept = "application/problem+json",
}

/**
 * Get MCP tool GitHub repository access
 *
 * @remarks
 * Returns the current GitHub repository access configuration for an MCP tool. If mode is "all", the tool has access to all repositories the project can access. If mode is "selected", the tool is scoped to specific repositories.
 */
export function toolsGetMcpToolGithubAccess(
  client$: InkeepAgentsCore,
  request: GetMcpToolGithubAccessRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    GetMcpToolGithubAccessResponse,
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >
> {
  return new APIPromise($do(
    client$,
    request,
    options,
  ));
}

async function $do(
  client$: InkeepAgentsCore,
  request: GetMcpToolGithubAccessRequest,
  options?: RequestOptions & {
    acceptHeaderOverride?: GetMcpToolGithubAccessAcceptEnum;
  },
): Promise<
  [
    Result<
      GetMcpToolGithubAccessResponse,
      | APIError
      | SDKValidationError
      | UnexpectedClientError
      | InvalidRequestError
      | RequestAbortedError
      | RequestTimeoutError
      | ConnectionError
    >,
    APICall,
  ]
> {
  const parsed$ = safeParse(
    request,
    (value$) => GetMcpToolGithubAccessRequest$zodSchema.parse(value$),
    "Input validation failed",
  );
  if (!parsed$.ok) {
    return [parsed$, { status: "invalid" }];
  }
  const payload$ = parsed$.value;
  const body$ = null;

  const pathParams$ = {
    projectId: encodeSimple("projectId", payload$.projectId, {
      explode: false,
      charEncoding: "percent",
    }),
    tenantId: encodeSimple("tenantId", payload$.tenantId, {
      explode: false,
      charEncoding: "percent",
    }),
    toolId: encodeSimple("toolId", payload$.toolId, {
      explode: false,
      charEncoding: "percent",
    }),
  };
  const path$ = pathToFunc(
    "/manage/tenants/{tenantId}/projects/{projectId}/tools/{toolId}/github-access",
  )(
    pathParams$,
  );

  const headers$ = new Headers(compactMap({
    Accept: options?.acceptHeaderOverride
      || "application/json;q=1, application/problem+json;q=0",
  }));
  const securityInput = await extractSecurity(client$._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client$._options,
    baseURL: options?.serverURL ?? client$._baseURL ?? "",
    operationID: "get-mcp-tool-github-access",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client$._options.security,
    retryConfig: options?.retries
      || client$._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || [
      "429",
      "500",
      "502",
      "503",
      "504",
    ],
  };

  const requestRes = client$._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path$,
    headers: headers$,
    body: body$,
    userAgent: client$._options.userAgent,
    timeoutMs: options?.timeoutMs || client$._options.timeoutMs
      || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req$ = requestRes.value;

  const doResult = await client$._do(req$, {
    context,
    errorCodes: [],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req$ }];
  }
  const response = doResult.value;
  const responseFields$ = {
    HttpMeta: { Response: response, Request: req$ },
  };

  const [result$] = await M.match<
    GetMcpToolGithubAccessResponse,
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >(
    M.json(200, GetMcpToolGithubAccessResponse$zodSchema, { key: "object" }),
    M.json(400, GetMcpToolGithubAccessResponse$zodSchema, {
      ctype: "application/problem+json",
      key: "BadRequest",
    }),
    M.json(401, GetMcpToolGithubAccessResponse$zodSchema, {
      ctype: "application/problem+json",
      key: "Unauthorized",
    }),
    M.json(403, GetMcpToolGithubAccessResponse$zodSchema, {
      ctype: "application/problem+json",
      key: "Forbidden",
    }),
    M.json(404, GetMcpToolGithubAccessResponse$zodSchema, {
      ctype: "application/problem+json",
      key: "NotFound",
    }),
    M.json(422, GetMcpToolGithubAccessResponse$zodSchema, {
      ctype: "application/problem+json",
      key: "UnprocessableEntity",
    }),
    M.json(500, GetMcpToolGithubAccessResponse$zodSchema, {
      ctype: "application/problem+json",
      key: "InternalServerError",
    }),
  )(response, req$, { extraFields: responseFields$ });

  return [result$, { status: "complete", request: req$, response }];
}
