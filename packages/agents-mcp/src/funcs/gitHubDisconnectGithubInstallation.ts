/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: be27bc484e20
 */

import { InkeepAgentsCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  DisconnectGithubInstallationRequest,
  DisconnectGithubInstallationRequest$zodSchema,
  DisconnectGithubInstallationResponse,
  DisconnectGithubInstallationResponse$zodSchema,
} from "../models/disconnectgithubinstallationop.js";
import { APIError } from "../models/errors/apierror.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

export enum DisconnectGithubInstallationAcceptEnum {
  applicationJsonAccept = "application/json",
  applicationProblemPlusJsonAccept = "application/problem+json",
}

/**
 * Disconnect a GitHub App installation
 *
 * @remarks
 * Disconnects a GitHub App installation from the tenant. This soft deletes the installation (sets status to "disconnected") and removes all project repository access entries. The installation record is preserved for audit purposes. Note: This does NOT uninstall the GitHub App from GitHub - the user can do that separately from GitHub settings.
 */
export function gitHubDisconnectGithubInstallation(
  client$: InkeepAgentsCore,
  request: DisconnectGithubInstallationRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    DisconnectGithubInstallationResponse,
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >
> {
  return new APIPromise($do(
    client$,
    request,
    options,
  ));
}

async function $do(
  client$: InkeepAgentsCore,
  request: DisconnectGithubInstallationRequest,
  options?: RequestOptions & {
    acceptHeaderOverride?: DisconnectGithubInstallationAcceptEnum;
  },
): Promise<
  [
    Result<
      DisconnectGithubInstallationResponse,
      | APIError
      | SDKValidationError
      | UnexpectedClientError
      | InvalidRequestError
      | RequestAbortedError
      | RequestTimeoutError
      | ConnectionError
    >,
    APICall,
  ]
> {
  const parsed$ = safeParse(
    request,
    (value$) => DisconnectGithubInstallationRequest$zodSchema.parse(value$),
    "Input validation failed",
  );
  if (!parsed$.ok) {
    return [parsed$, { status: "invalid" }];
  }
  const payload$ = parsed$.value;
  const body$ = null;

  const pathParams$ = {
    installationId: encodeSimple("installationId", payload$.installationId, {
      explode: false,
      charEncoding: "percent",
    }),
    tenantId: encodeSimple("tenantId", payload$.tenantId, {
      explode: false,
      charEncoding: "percent",
    }),
  };
  const path$ = pathToFunc(
    "/manage/tenants/{tenantId}/github/installations/{installationId}/disconnect",
  )(
    pathParams$,
  );

  const headers$ = new Headers(compactMap({
    Accept: options?.acceptHeaderOverride
      || "application/json;q=1, application/problem+json;q=0",
  }));
  const securityInput = await extractSecurity(client$._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client$._options,
    baseURL: options?.serverURL ?? client$._baseURL ?? "",
    operationID: "disconnect-github-installation",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client$._options.security,
    retryConfig: options?.retries
      || client$._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || [
      "429",
      "500",
      "502",
      "503",
      "504",
    ],
  };

  const requestRes = client$._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path$,
    headers: headers$,
    body: body$,
    userAgent: client$._options.userAgent,
    timeoutMs: options?.timeoutMs || client$._options.timeoutMs
      || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req$ = requestRes.value;

  const doResult = await client$._do(req$, {
    context,
    errorCodes: [],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req$ }];
  }
  const response = doResult.value;
  const responseFields$ = {
    HttpMeta: { Response: response, Request: req$ },
  };

  const [result$] = await M.match<
    DisconnectGithubInstallationResponse,
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >(
    M.json(200, DisconnectGithubInstallationResponse$zodSchema, {
      key: "object",
    }),
    M.json(400, DisconnectGithubInstallationResponse$zodSchema, {
      ctype: "application/problem+json",
      key: "BadRequest",
    }),
    M.json(401, DisconnectGithubInstallationResponse$zodSchema, {
      ctype: "application/problem+json",
      key: "Unauthorized",
    }),
    M.json(403, DisconnectGithubInstallationResponse$zodSchema, {
      ctype: "application/problem+json",
      key: "Forbidden",
    }),
    M.json(422, DisconnectGithubInstallationResponse$zodSchema, {
      ctype: "application/problem+json",
      key: "UnprocessableEntity",
    }),
    M.json(500, DisconnectGithubInstallationResponse$zodSchema, {
      ctype: "application/problem+json",
      key: "InternalServerError",
    }),
  )(response, req$, { extraFields: responseFields$ });

  return [result$, { status: "complete", request: req$, response }];
}
