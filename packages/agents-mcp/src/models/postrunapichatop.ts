/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { ClosedEnum } from "../types/enums.js";
import { BadRequest, BadRequest$zodSchema } from "./badrequest.js";
import { Forbidden, Forbidden$zodSchema } from "./forbidden.js";
import {
  InternalServerError,
  InternalServerError$zodSchema,
} from "./internalservererror.js";
import { NotFound, NotFound$zodSchema } from "./notfound.js";
import { Unauthorized, Unauthorized$zodSchema } from "./unauthorized.js";
import {
  UnprocessableEntity,
  UnprocessableEntity$zodSchema,
} from "./unprocessableentity.js";

export type PostRunApiChatSecurity = { bearerAuth: string };

export const PostRunApiChatSecurity$zodSchema: z.ZodType<
  PostRunApiChatSecurity
> = z.object({
  bearerAuth: z.string().describe(
    "Bearer token authentication. Use this for API clients and service-to-service communication. Set the Authorization header to \"Bearer <token>\".",
  ),
});

export const PostRunApiChatRole = {
  System: "system",
  User: "user",
  Assistant: "assistant",
  Function: "function",
  Tool: "tool",
} as const;
export type PostRunApiChatRole = ClosedEnum<typeof PostRunApiChatRole>;

export const PostRunApiChatRole$zodSchema = z.enum([
  "system",
  "user",
  "assistant",
  "function",
  "tool",
]);

export const TypeStepStart = {
  StepStart: "step-start",
} as const;
export type TypeStepStart = ClosedEnum<typeof TypeStepStart>;

export const TypeStepStart$zodSchema = z.enum([
  "step-start",
]);

export type PartStepStart = { type: TypeStepStart };

export const PartStepStart$zodSchema: z.ZodType<PartStepStart> = z.object({
  type: TypeStepStart$zodSchema,
});

export type Approval = {
  id: string;
  approved?: boolean | undefined;
  reason?: string | undefined;
};

export const Approval$zodSchema: z.ZodType<Approval> = z.object({
  approved: z.boolean().optional(),
  id: z.string(),
  reason: z.string().optional(),
});

export type Part2 = {
  type: string;
  toolCallId: string;
  state?: any | null | undefined;
  approval?: Approval | undefined;
  input?: any | null | undefined;
  callProviderMetadata?: any | null | undefined;
};

export const Part2$zodSchema: z.ZodType<Part2> = z.object({
  approval: z.lazy(() => Approval$zodSchema).optional(),
  callProviderMetadata: z.any().nullable().optional(),
  input: z.any().nullable().optional(),
  state: z.any().nullable().optional(),
  toolCallId: z.string(),
  type: z.string(),
});

export const PostRunApiChatTypeEnum = {
  Text: "text",
  Image: "image",
  Audio: "audio",
  Video: "video",
  File: "file",
} as const;
export type PostRunApiChatTypeEnum = ClosedEnum<typeof PostRunApiChatTypeEnum>;

export const PostRunApiChatTypeEnum$zodSchema = z.enum([
  "text",
  "image",
  "audio",
  "video",
  "file",
]);

export type Type = PostRunApiChatTypeEnum | string;

export const Type$zodSchema: z.ZodType<Type> = z.union([
  PostRunApiChatTypeEnum$zodSchema,
  z.string(),
]);

export type Part1 = {
  type: PostRunApiChatTypeEnum | string;
  text?: string | undefined;
};

export const Part1$zodSchema: z.ZodType<Part1> = z.object({
  text: z.string().optional(),
  type: z.union([
    PostRunApiChatTypeEnum$zodSchema,
    z.string(),
  ]),
});

export type PartUnion = Part2 | Part1 | PartStepStart;

export const PartUnion$zodSchema: z.ZodType<PartUnion> = z.union([
  z.lazy(() => Part2$zodSchema),
  z.lazy(() => Part1$zodSchema),
  z.lazy(() => PartStepStart$zodSchema),
]);

export type PostRunApiChatMessage = {
  role: PostRunApiChatRole;
  content?: any | null | undefined;
  parts?: Array<Part2 | Part1 | PartStepStart> | undefined;
};

export const PostRunApiChatMessage$zodSchema: z.ZodType<PostRunApiChatMessage> =
  z.object({
    content: z.any().nullable().optional(),
    parts: z.array(z.union([
      z.lazy(() => Part2$zodSchema),
      z.lazy(() => Part1$zodSchema),
      z.lazy(() => PartStepStart$zodSchema),
    ])).optional(),
    role: PostRunApiChatRole$zodSchema,
  });

export type PostRunApiChatRequest = {
  model?: string | undefined;
  messages: Array<PostRunApiChatMessage>;
  id?: string | undefined;
  conversationId?: string | undefined;
  stream?: boolean | undefined;
  max_tokens?: number | undefined;
  headers?: { [k: string]: any | null } | undefined;
  runConfig?: { [k: string]: any | null } | undefined;
};

export const PostRunApiChatRequest$zodSchema: z.ZodType<PostRunApiChatRequest> =
  z.object({
    conversationId: z.string().optional(),
    headers: z.record(z.string(), z.any().nullable()).optional(),
    id: z.string().optional(),
    max_tokens: z.number().optional(),
    messages: z.array(z.lazy(() => PostRunApiChatMessage$zodSchema)),
    model: z.string().optional(),
    runConfig: z.record(z.string(), z.any().nullable()).optional(),
    stream: z.boolean().default(true),
  });

export type PostRunApiChatResponse = {
  ContentType: string;
  StatusCode: number;
  RawResponse: Response;
  BadRequest?: BadRequest | undefined;
  Unauthorized?: Unauthorized | undefined;
  Forbidden?: Forbidden | undefined;
  NotFound?: NotFound | undefined;
  UnprocessableEntity?: UnprocessableEntity | undefined;
  InternalServerError?: InternalServerError | undefined;
  Headers: { [k: string]: Array<string> };
};

export const PostRunApiChatResponse$zodSchema: z.ZodType<
  PostRunApiChatResponse
> = z.object({
  BadRequest: BadRequest$zodSchema.optional(),
  ContentType: z.string(),
  Forbidden: Forbidden$zodSchema.optional(),
  Headers: z.record(z.string(), z.array(z.string())).default({}),
  InternalServerError: InternalServerError$zodSchema.optional(),
  NotFound: NotFound$zodSchema.optional(),
  RawResponse: z.custom<Response>(x => x instanceof Response),
  StatusCode: z.int(),
  Unauthorized: Unauthorized$zodSchema.optional(),
  UnprocessableEntity: UnprocessableEntity$zodSchema.optional(),
});
