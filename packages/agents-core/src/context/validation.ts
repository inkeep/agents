import { z } from 'zod';

/** 1) Your schemas */
const userFetcher = z.object({
  name: z.string(),
  email: z.string().email(),
});

const projectAutogenInfoSchema = z.object({
  chatSubjectName: z.string().nullable(),
  botCreator: z.string().nullable(),
  botName: z.string().nullable(),
  oneLineDescription: z.string().nullable(),
  primaryLanguage: z.string().nullable(),
  autogeneratedDescription: z.string().nullable(),
  productLines: z
    .array(
      z.object({
        aliases: z.array(z.string()).nullable(),
        description: z.string(),
        integrations: z.array(z.string()).nullable(),
        primaryTerm: z.string(),
        versions: z
          .array(
            z.object({
              name: z.string(),
              aliases: z.array(z.string()).nullable(),
              description: z.string(),
              releaseDate: z.string().nullable(),
              isLatest: z.boolean().nullable(),
            })
          )
          .nullable(),
      })
    )
    .nullable(),
  keyTerms: z
    .array(
      z.object({
        primaryTerm: z.string(),
        aliases: z.array(z.string()).nullable(),
        category: z.string().nullable(),
        definition: z.string(),
        example: z.string().nullable(),
      })
    )
    .nullable(),
});

const contextVariables = {
  userInfo: userFetcher,
  projectAutogenInfo: projectAutogenInfoSchema,
} as const;

/** 2) Build a runtime type from zod, preserving keys */
type ZodToTs<T extends Record<string, z.ZodTypeAny>> = {
  [K in keyof T]: z.infer<T[K]>;
};
type Context = ZodToTs<typeof contextVariables>;

type Primitive = string | number | boolean | bigint | symbol | null | undefined | Date;

type JoinDot<P extends string, K extends string> = [P] extends [''] ? K : `${P}.${K}`;

export type DotPaths<T, P extends string = ''> = [T] extends [Primitive] // primitives (including null/undefined) — the path ends here
  ? P
  : // arrays — no dot before brackets; allow both [number] and [*]
    T extends ReadonlyArray<infer U>
    ? P | DotPaths<U, `${P}[${number}]`> | DotPaths<U, `${P}[*]`>
    : T extends Array<infer U>
      ? P | DotPaths<U, `${P}[${number}]`> | DotPaths<U, `${P}[*]`>
      : // objects — recurse on keys with dot join
        T extends object
        ? { [K in Extract<keyof T, string>]: DotPaths<T[K], JoinDot<P, K>> }[Extract<
            keyof T,
            string
          >]
        : P;
export type AllowedPaths = DotPaths<Context>;

/** 4) The function you ship: path autocomplete + validation, returns {{path}} */
export function toTemplate<P extends AllowedPaths>(path: P): `{{${P}}}` {
  return `{{${path}}}` as `{{${P}}}`;
}

/** 6) Factory that binds everything to your specific contextVariables */
export function createTemplateHelpers<T extends Record<string, z.ZodTypeAny>>(_: T) {
  type Ctx = { [K in keyof T]: z.infer<T[K]> };
  type Paths = DotPaths<Ctx>;
  return {
    /** Autocomplete & validate literal paths */
    toTemplate<P extends Paths>(p: P): `{{${P}}}` {
      return `{{${p}}}` as `{{${P}}}`;
    },
  };
}

/** 7) Usage */
const { toTemplate: templateHelper } = createTemplateHelpers(contextVariables);

const a = templateHelper('userInfo.name'); // typed OK, returns "{{userInfo.name}}"
const b = templateHelper('userInfo.name'); // ❌ TS error, autocomplete suggests "name" / "email"
const c = templateHelper('projectAutogenInfo.productLines[0].versions[0].name'); // typed OK, returns "{{projectAutogenInfo.productLines[0].primaryTerm.aliases[0]}}"

console.log(c);
