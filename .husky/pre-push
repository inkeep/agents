#!/bin/sh
# Pre-push hook for Agent Framework
#
# This hook runs before each push to ensure code quality.
# It uses turbo's affected-only filtering to only check packages
# that have changed since origin/main, making it much faster.
#
# Performance optimizations:
#   - Only checks packages affected by your changes (--filter='...[origin/main]')
#   - Uses turbo remote caching when configured (see scripts/setup-turbo-cache.sh)
#   - Excludes docs and cookbook templates from checks
#
# Usage:
#   Normal push:                      git push
#   Skip all hooks (use sparingly):   git push --no-verify
#
# For more information, see CONTRIBUTING.md

set -e

# Configuration
TIMEOUT_SECONDS=300  # 5 minutes timeout
RETRY_COUNT=1

# Ensure we're in the repository root
cd "$(git rev-parse --show-toplevel)" || exit 1

# Determine the base ref for affected filtering
# Try to use origin/main, fall back to HEAD~1 if not available
get_base_ref() {
  if git rev-parse --verify origin/main >/dev/null 2>&1; then
    echo "origin/main"
  elif git rev-parse --verify main >/dev/null 2>&1; then
    echo "main"
  else
    # Fallback: compare against parent commit
    echo "HEAD~1"
  fi
}

BASE_REF=$(get_base_ref)

# Check if there are any changes affecting packages
has_package_changes() {
  # Check if any non-ignored files have changed
  git diff --name-only "$BASE_REF"...HEAD 2>/dev/null | grep -qvE '^(\.github/|docs/|\.md$|\.txt$)' || \
  git diff --name-only HEAD 2>/dev/null | grep -qvE '^(\.github/|docs/|\.md$|\.txt$)'
}

echo "üöÄ Running pre-push checks..."
echo "   Using affected-only mode (comparing against $BASE_REF)"

# Show cache status
if [ -n "$TURBO_TOKEN" ] && [ -n "$TURBO_TEAM" ]; then
  echo "   ‚úÖ Remote caching enabled (team: $TURBO_TEAM)"
else
  echo "   ‚ö†Ô∏è  Remote caching not configured (run: pnpm turbo:login)"
fi

# Build the turbo command with affected-only filtering
# Excludes: agents-cookbook-templates, agents-docs (docs don't need pre-push validation)
TURBO_FILTER="--filter='...[$BASE_REF]' --filter='!agents-cookbook-templates' --filter='!@inkeep/agents-docs'"

# Function to run command with timeout detection
run_with_timeout() {
  local timeout=$1
  local attempt=$2
  
  echo ""
  if [ "$attempt" -gt 1 ]; then
    echo "   ‚ö†Ô∏è  Retry attempt $attempt after clearing cache..."
  fi
  
  # Run command in background and capture PID and process group
  # Force stream UI mode (not TUI) for non-interactive git hook environment
  eval "TURBO_UI=stream pnpm turbo check:husky $TURBO_FILTER" &
  local cmd_pid=$!
  local pgid=$(ps -o pgid= -p $cmd_pid 2>/dev/null | tr -d ' ' || echo "")
  
  # Monitor the process
  local elapsed=0
  local check_interval=5  # Check every 5 seconds
  
  while [ $elapsed -lt $timeout ]; do
    # Check if process is still running
    if ! kill -0 $cmd_pid 2>/dev/null; then
      # Process completed, wait for exit code
      wait $cmd_pid
      return $?
    fi
    
    # Sleep and increment elapsed time
    sleep $check_interval
    elapsed=$((elapsed + check_interval))
    
    # Print progress every 60 seconds
    if [ $((elapsed % 60)) -eq 0 ]; then
      echo "   ‚è≥ Still running... (${elapsed}s / ${timeout}s)"
    fi
  done
  
  # Timeout reached - process is hanging
  echo ""
  echo "   ‚ö†Ô∏è  Command appears to be hanging (timeout after ${timeout}s)"
  echo "   üîç Killing process group (PID: $cmd_pid, PGID: ${pgid:-N/A})..."
  
  # Try to kill gracefully first (entire process group if available)
  if [ -n "$pgid" ] && [ "$pgid" != "1" ]; then
    kill -TERM -$pgid 2>/dev/null || kill $cmd_pid 2>/dev/null || true
  else
    kill $cmd_pid 2>/dev/null || true
  fi
  sleep 2
  
  # Force kill if still running
  if kill -0 $cmd_pid 2>/dev/null; then
    echo "   üîç Force killing process group..."
    if [ -n "$pgid" ] && [ "$pgid" != "1" ]; then
      kill -9 -$pgid 2>/dev/null || kill -9 $cmd_pid 2>/dev/null || true
    else
      kill -9 $cmd_pid 2>/dev/null || true
    fi
  fi
  
  # Wait for process to die
  wait $cmd_pid 2>/dev/null || true
  
  return 124  # Return timeout exit code (same as timeout command)
}

# Function to clear turbo cache
clear_turbo_cache() {
  echo ""
  echo "   üßπ Clearing turbo cache..."
  rm -rf .turbo 2>/dev/null || true
  echo "   ‚úÖ Cache cleared"
}

# Try running the command with retries
attempt=1
max_attempts=$((RETRY_COUNT + 1))
success=false

while [ $attempt -le $max_attempts ]; do
  if run_with_timeout $TIMEOUT_SECONDS $attempt; then
    success=true
    break
  fi
  
  exit_code=$?
  
  if [ $exit_code -eq 124 ]; then
    # Timeout detected
    if [ $attempt -lt $max_attempts ]; then
      clear_turbo_cache
      attempt=$((attempt + 1))
      echo ""
      echo "   üîÑ Retrying after cache clear..."
    else
      echo ""
      echo "‚ùå Pre-push checks timed out after ${max_attempts} attempt(s)."
      echo ""
      echo "   The command appears to be hanging. This may be due to:"
      echo "   1. Corrupted turbo cache (already cleared)"
      echo "   2. Resource exhaustion"
      echo "   3. Network issues (if using remote cache)"
      echo ""
      echo "   Try running manually:"
      echo "   1. pnpm clean:turbo"
      echo "   2. pnpm check:husky"
      exit 1
    fi
  else
    # Command failed with error (not timeout)
    echo ""
    echo "‚ùå Pre-push checks failed. Fix the issues above before pushing."
    echo "   Run 'pnpm check:husky' locally to reproduce."
    exit $exit_code
  fi
done

if [ "$success" = true ]; then
  echo ""
  echo "‚úÖ Pre-push checks passed!"
fi
