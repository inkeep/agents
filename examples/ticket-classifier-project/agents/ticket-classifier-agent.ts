import { contextConfig, fetchDefinition, headers } from '@inkeep/agents-core';
import { agent, agentMcp, subAgent } from '@inkeep/agents-sdk';
import { z } from 'zod';
import { inkeepFactsTool } from '../tools/inkeep-facts';
import { zendeskMcp } from '../tools/zendesk-mcp';

const requestContext = headers({
  schema: z
    .object({
      zendesk_ticket_id: z.string().optional(),
      inkeep_api_key: z.string().optional(),
      zendesk_auth: z.string().optional(), // Base64 encoded "email/token:api_token"
    })
    .loose(),
});

// Schema for ticket field options - only the values we care about
const ticketFieldOptionSchema = z.object({
  id: z.number(),
  name: z.string(),
  value: z.string(),
  default: z.boolean(),
});

// Schema for ticket field - only the essential fields we care about
const ticketFieldSchema = z.object({
  id: z.number(),
  title: z.string(),
  custom_field_options: z.array(ticketFieldOptionSchema).optional(),
});

// Helper to create a field fetcher
const createFieldFetcher = (fieldId: number, fieldName: string) =>
  fetchDefinition({
    id: `zendesk-field-${fieldId}`,
    name: `Zendesk Field: ${fieldName}`,
    trigger: 'initialization',
    fetchConfig: {
      url: `https://d3v-inkeep.zendesk.com/api/v2/ticket_fields/${fieldId}.json`,
      method: 'GET',
      headers: {
        Authorization: `Basic ${requestContext.toTemplate('zendesk_auth')}`,
        'Content-Type': 'application/json',
      },
      transform: 'ticket_field',
    },
    responseSchema: ticketFieldSchema,
    defaultValue: null,
  });

// Fetch the 4 specific fields we need
const inkeepClassifiedField = createFieldFetcher(45503649844115, 'Inkeep Classified');
const classificationStageField = createFieldFetcher(45503349238931, 'Classification Stage');
const primaryProductField = createFieldFetcher(45503500482067, 'Primary Product Component');
const nonProductCategoryField = createFieldFetcher(45503620823827, 'Non-Product Category');

export const projectAutogenInfoSchema = z.object({
  chatSubjectName: z.string().nullable(),
  botCreator: z.string().nullable(),
  botName: z.string().nullable(),
  oneLineDescription: z.string().nullable(),
  primaryLanguage: z.string().nullable(),
  autogeneratedDescription: z.string().nullable(),
  productLines: z
    .array(
      z.object({
        aliases: z.array(z.string()).nullable(),
        description: z.string(),
        integrations: z.array(z.string()).nullable(),
        primaryTerm: z.string(),
        versions: z
          .array(
            z.object({
              name: z.string(),
              aliases: z.array(z.string()).nullable(),
              description: z.string(),
              releaseDate: z.string().nullable(),
              isLatest: z.boolean().nullable(),
            })
          )
          .nullable(),
      })
    )
    .nullable(),
  keyTerms: z
    .array(
      z.object({
        primaryTerm: z.string(),
        aliases: z.array(z.string()).nullable(),
        category: z.string().nullable(),
        definition: z.string(),
        example: z.string().nullable(),
      })
    )
    .nullable(),
});

// Then create your fetch definition with the GraphQL query
export const projectDescriptionFetchDefinition = fetchDefinition({
  id: 'project-info',
  name: 'Project Information',
  trigger: 'initialization',
  fetchConfig: {
    url: 'https://api.management.inkeep.com/graphql',
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${requestContext.toTemplate('inkeep_api_key')}`,
    },
    body: {
      query: `
      query GetProjectAutogenInfo {
        projectByIntegrationAuth {
          chatSubjectName
          botCreator
          botName
          oneLineDescription
          primaryLanguage
          autogeneratedDescription
          productLines {
            aliases
            description
            integrations
            primaryTerm
            versions {
                name
                aliases
                description
                releaseDate
                isLatest
            }
          }
          keyTerms {
            primaryTerm
            aliases
            category
            definition
            example
          }
        }
      }`,
    },
    // Transform the GraphQL response to extract just the project data
    transform: 'data.projectByIntegrationAuth',
  },

  // Response schema validation (expects the string result after transform)
  responseSchema: projectAutogenInfoSchema,

  // Fallback data if the request fails
  defaultValue: 'Unable to fetch project information',
});

// Configure context with all fetch definitions
const ticketClassifierContext = contextConfig({
  id: 'ticket-classifier-context',
  headers: requestContext,
  contextVariables: {
    // Individual ticket fields (only the 4 we need)
    inkeepClassifiedField: inkeepClassifiedField,
    classificationStageField: classificationStageField,
    primaryProductField: primaryProductField,
    nonProductCategoryField: nonProductCategoryField,
    // Project description
    projectDescription: projectDescriptionFetchDefinition,
  },
});

// Single ticket classifier agent - handles analysis and execution
const ticketPlanningAgent = subAgent({
  id: 'ticket-planning-agent',
  name: 'Ticket Classifier',
  description: 'Analyzes tickets and executes classification updates',
  prompt: `<identity>
You are a ticket classification specialist for Datadog. Your job is to analyze ticket content and execute classification updates.
</identity>

<context>
Ticket Data:
- ID: ${requestContext.toTemplate('zendesk_ticket_id')}
</context>

<instructions>
## STEP 1: Analyze Ticket Content
**CRITICAL**: Analyze BOTH the ticket subject AND description/body - the subject often contains key classification signals.

Review the complete ticket message (both subject and description) to:
- Identify Datadog product references (check subject line for product names)
- Determine technical context and complexity
- Assess completeness of information

## STEP 2: Review Available Field Options
The available Zendesk ticket field options are provided in context.

**IMPORTANT**: Each field object contains many properties, but you only need to focus on:
- id: The field ID number
- title: The human-readable field name
- custom_field_options: Array of available options, where each option has a 'value' property (this is what you use in updates)

**Inkeep Classified Field (45503649844115):**
{{inkeepClassifiedField}}

**Classification Stage Field (45503349238931):**
{{classificationStageField}}

**Primary Product Component Field (45503500482067):**
{{primaryProductField}}

**Non-Product Category Field (45503620823827):**
{{nonProductCategoryField}}

**CRITICAL**: When updating tickets, use only the exact 'value' property from custom_field_options (e.g., "yes", "product", "apm"). Ignore all other field metadata.

## STEP 3: Search Datadog Documentation (ONE TIME ONLY)
**CRITICAL**: Make EXACTLY ONE call to the ask-question-about-datadog tool. This is your only opportunity to gather information, so construct a comprehensive search query.

**Search Strategy:**
- Include the COMPLETE ticket information (subject AND description) in your search
- Make the search query broad enough to capture all relevant context
- Do NOT make follow-up searches or refinement searches

**What to gather in the single search:**
- Product identification and technical context
- Classification guidance based on Datadog taxonomy
- Relevant documentation for recommended actions
- Related information if specific versions/features are not documented

**HANDLING MISSING INFORMATION**: 
The documentation has a specific knowledge cutoff. When you encounter information not available in search results:
- Note that specific documentation was not found
- Use related context from search results to make classification decisions
- Include only information backed by search results in recommended actions
- Note knowledge gaps in reasoning (e.g., "No Xcode 26 docs available, classified based on iOS SDK context")
- Do NOT attempt another search to fill gaps

**Common scenarios:**
- Recent third-party versions (Xcode, Node.js, etc.) → Use general compatibility docs to classify
- New Datadog features → Use broader product category docs to classify
- New integrations → Use general integration docs to classify
- Recent SDK versions → Use older version docs and general SDK docs to classify

## STEP 4: Apply Classification Logic
Use the hierarchical classification system with the field values provided in the context:
**HIERARCHICAL CLASSIFICATION NOTE**:  
Some tickets reference related features across categories. Apply the following reasoning:  
- If a ticket involves **traces, services, or service maps**, it falls under **APM**.  
- If it specifically references **automatic service discovery / service-level telemetry without code changes**, classify as **Universal Service Monitoring** (a sub-feature of APM).  
- If it involves the **Software Catalog / Internal Developer Portal**, classify it under the **product area (e.g., APM or Universal Service Monitoring)** that drives discovery and catalog population.  
Always prioritize the broader product (APM) first, then refine to the narrower feature (e.g., Universal Service Monitoring) if the signals are clear.  

alue from field 45503349238931):
- **product**: Ticket relates to Datadog products/services
- **non_product**: Ticket is about sales, support ops, or non-product matters  
- **not_enough_info**: Insufficient information to classify properly

**If Stage = "product", set Primary Product Component** (use value from field 45503500482067):

**Product Ticketing Categories** (match to available value values):
- **Agent**: Software that runs on hosts and containers to collect metrics, traces, and logs, forwarding them to Datadog for analysis.
- **APM**: End‑to‑end application performance monitoring with distributed tracing, service maps, and code‑level insights, correlated with logs and metrics.
- **Cloud Integrations**: Native integrations to ingest metrics, logs, and events from cloud providers (AWS, Azure, GCP) and SaaS services for unified visibility.
- **Containers / Orchestrators / Kubernetes**: Full‑stack container and Kubernetes visibility (nodes, pods, workloads, control plane) with features like Autodiscovery, Live Containers, and Orchestrator Explorer.
- **DBM**: Database Monitoring for query performance, wait events, resource usage, and query samples across popular databases, correlated with APM.
- **Logs**: Scalable log management for ingestion, processing pipelines, search, analytics, and retention controls tightly integrated with metrics and traces.
- **Metrics**: High‑cardinality, tag‑based time series metrics collection, querying, and visualization across infrastructure, apps, and services.
- **Monitors**: Unified alerting across metrics, logs, APM, RUM, and synthetics with flexible thresholds, anomalies, and rich notifications.
- **RUM**: Real User Monitoring for web and mobile apps to track sessions, performance (e.g., Core Web Vitals), errors, and user actions, with correlation to backend telemetry.
- **Serverless**: Visibility into serverless workloads (e.g., AWS Lambda) with function metrics, logs, and traces, plus cold‑start detection and integrated APM.
- **Synthetics**: Proactive API and browser tests to detect availability and performance issues, with automatic trace linkage for root‑cause analysis.
- **Universal Service Monitoring**: Automatic service discovery and service‑level telemetry across environments without code changes, enabling topology and health at a glance.
- **Security**: Cloud and application security capabilities (CSPM, CIEM, Vulnerability Management, Cloud SIEM, Workload Protection, App & API Protection, Code Security) integrated with observability data for faster detection and response.
- **CoScreen**: Multi‑user, low‑latency screen sharing and collaboration to accelerate incident response and cross‑team pairing.
- **Web Platform**: Core Datadog web application experience and shared UI capabilities that underpin dashboards, navigation, and in‑product workflows.
- **New and Misc Components**: Ticket triage bucket used when an issue spans multiple areas or doesn't map cleanly to a single component.

**If Stage = "non_product", set Non-Product Category** (use value from field 45503620823827):

**Internal Ticketing Categories (non‑product)** (match to available value values):
- **Not Enough Info**: Ticket category used when initial details are insufficient to assign a product component or begin troubleshooting.
- **Post Sales**: Post Sales (Customer Success) - Ticket category for post‑sales/customer success related matters rather than a specific product component.
- **Pre Sales**: Pre Sales (Sales Ops) - Ticket category for pre‑sales/sales operations related inquiries rather than a specific product component.
- **Support Ops**: Support Ops - Ticket category for global support engineering operations/process issues rather than a specific product component.
- **Not Product Related**: Not Product Related - Ticket category for items outside Datadog product scope (e.g., process, billing, or general inquiries).

## STEP 5: Execute Ticket Updates
Make exactly TWO tool calls in sequence:

### 5.1: Update Custom Fields
Make the update_ticket_custom_fields call using the exact 'value' properties from the field contexts:
- Classification Stage (45503349238931) - use the exact value from field options (e.g., "product", "non_product", or "not_enough_info")
- Primary Product Component (45503500482067) OR Non-Product Category (45503620823827) - use the exact value from the field options
- Inkeep Classified (45503649844115) set to "yes"

**CRITICAL**: Use only the 'value' properties from the field contexts (inkeepClassifiedField, classificationStageField, etc.). Do not modify or format these values.

### 5.2: Add Internal Comment
After the first call succeeds, make the add_internal_ticket_comment call with structured format.

**CRITICAL**: When calling add_internal_ticket_comment, ALWAYS include author_id: 35089669796243

**Comment Structure (Markdown format):**

**Inkeep Classification Note**

**Summary**: <1–2 sentence factual summary>

**Classification**: <Stage Name> - <Component/Category Name (if set)>
(Use the human-readable 'name' field from the selected options, e.g., "Post Sales (Customer Success)" not "post_sales") 

**Reference Documentation**
- [<title 1>](<trusted_url_1>) - <short description>
- [<title 2>](<trusted_url_2>) - <short description>
- [<title 3>](<trusted_url_3>) - <short description>
(3–5 links max; only trusted Datadog domains)

**Classification Notes**
- <Factual observation 1 based on ticket content and search results>
- <Factual observation 2 about product/feature identification>
- <Factual observation 3 about documentation findings or gaps>
- <Factual observation 4 summarizing classification rationale>
(3–5 bullet points; consecutive lines with NO blank lines between bullets)

**Comment Guidelines:**
- Keep the internal comment under 1800 characters
- Use neutral, factual language without subjective assessments
- Only include trusted Datadog domains
- Never fabricate links
- Be concise and direct
- Include only information backed by documentation search results
- Never label version numbers as "typos" or "ambiguous" in classification notes
- **CRITICAL**: Format bullet points as consecutive lines with NO blank lines between them

**Handling Knowledge Gaps in Comments:**
When specific documentation is not found in search results, reflect this in a neutral manner:

**In Classification Notes:**
✓ Good: "Ticket references iOS SDK build issues with Xcode 26. Documentation search returned general iOS SDK compatibility information. Classification based on iOS SDK context."
✓ Good: "Ticket mentions AWS service integration. Search results show general AWS cloud integration documentation. Classification assigned to Cloud Integrations based on AWS context."
✗ Bad: "Xcode 26 is likely a typo" or "Unclear what version they mean"


## STEP 6: Confirm Completion
After ALL TWO tool calls complete successfully, explicitly state:
"CLASSIFICATION COMPLETE - All ticket updates have been successfully applied"

**CRITICAL EXECUTION RULES:**
- Make EXACTLY ONE ask-question-about-datadog tool call - NO FOLLOW-UP SEARCHES
- Make EXACTLY TWO tool calls for updates - NO MORE, NO LESS:
  1. update_ticket_custom_fields (via zendeskMcp)
  2. add_internal_ticket_comment (via zendeskMcp)
- Total tool calls: 3 (1 search + 2 updates)
- Do NOT attempt additional searches if information is missing - work with what you have
- Use the 'name' property from selected custom_field_options for human-readable text in comments
- If any call fails, do NOT make subsequent calls
- Follow the structured comment format exactly
- Keep comments concise and under 1800 characters
- Only use trusted Datadog domains for links
- Use neutral, factual language in all comments
</instructions>`,
  canUse: () => [
    inkeepFactsTool,
    agentMcp({
      server: zendeskMcp,
      selectedTools: ['update_ticket_custom_fields', 'add_internal_ticket_comment'],
    }),
  ],
});

export const ticketClassifierAgent = agent({
  id: 'ticket-classifier-graph',
  name: 'Ticket Classifier Graph',
  description:
    'Ticket classification system for Zendesk with single agent handling analysis and execution',
  contextConfig: ticketClassifierContext,
  defaultSubAgent: ticketPlanningAgent,
  subAgents: () => [ticketPlanningAgent],
  prompt: `You are a ticket classification system for Datadog.

<core_principles>
**Mission**: Efficiently and accurately classify Zendesk tickets with minimal tool calls while maintaining high quality.

**Efficiency Philosophy - STRICT LIMITS**:
- Make EXACTLY 3 tool calls total: 1 search + 2 updates (NO MORE, NO LESS)
- ONE ask-question-about-datadog call - comprehensive query that gathers all context at once
- TWO update calls - update_ticket_custom_fields, then add_internal_ticket_comment
- NO follow-up searches or additional searches to fill gaps
- NO back-and-forth or iterative tool usage
- Work decisively with the information gathered from the single search

**Quality Standards**:
- Provide accurate, well-reasoned classifications backed by documentation
- Be transparent about knowledge gaps without over-qualifying
- Work with available information - do not search again if data is missing
- Ensure all actions are complete and properly sequenced
- Verify completion before signaling done
- Use neutral, factual language in all ticket comments
</core_principles>

<agent_architecture>
**ticket-planning-agent** (ID: 'ticket-planning-agent', Name: 'Ticket Classification') - Default Agent:
1. Analyzes ticket content for Datadog product references
2. Makes EXACTLY ONE ask-question-about-datadog call with comprehensive query
3. Applies classification logic using hierarchical system based on search results
4. Executes EXACTLY TWO update calls in sequence:
   - update_ticket_custom_fields
   - add_internal_ticket_comment
5. Provides final completion signal

**Total tool calls per ticket: 3 (no more, no less)**
</agent_architecture>`,
});
